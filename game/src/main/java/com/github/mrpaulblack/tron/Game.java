/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.mrpaulblack.tron;


import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import java.util.Map.Entry;

import org.json.JSONObject;

public class Game implements GameController {

    private Integer boardSize;
    private Integer tailLenght;
    private Integer playerNumber;
    private Integer cellSize;
    private Player[] user;
    private HashMap <UUID, PlayerColor> colorToID = new HashMap<UUID, PlayerColor>();
    private GameState gameState;
    int driverHeadX;
    int driverHeadY;
    private List<Integer> obstaclePositionsX = new ArrayList<Integer>();
    private List<Integer> obstaclePositionsY = new ArrayList<Integer>();
    

    //hashmap für ready player und UUID
    
    

    private HashMap <UUID, Player> participants =  new HashMap<UUID, Player>();


    public Game (Integer boardSize, Integer tailLenght, Integer playerNumber, Integer cellSize){
        this.boardSize = boardSize;
        this.tailLenght = tailLenght;
        this.playerNumber = playerNumber;
        this.cellSize = cellSize;
        this.gameState = GameState.SETTINGUP;
        
        
        //board.getStartPosi(UUID.randomUUID(), boardSize, participants.get(UUID.randomUUID())); <-- als Vorlage für Übergeben/Erstellen
    }
    
    @Override
    public void register(UUID playerID, String clientName, Float clientVersion){
        participants.put(playerID, new Player(clientName, clientVersion, playerID, tailLenght));        
    }

    @Override
    public void executeMove(UUID player, int moveChange){
        participants.get(player).move();
        //colliDetect.CollisionChecker(participants.get(player));   <-- wird noch ergänzt um 2 weitere Typen von Collision
    }

    @Override
    public PlayerColor colorCheck(PlayerColor color){
        
        if(colorToID.containsValue(color)){
            return PlayerColor.UNDEFINED;
        };
        return color;
    }

    @Override
    public boolean ready(UUID playerID, PlayerColor color, String playerName){
        int readyCount = 0;        
        participants.get(playerID).setReadyPlayer(playerName, color);
        colorToID.put(playerID, color);
        
        for (Entry <UUID, Player>clientEntry: participants.entrySet()){
            if(clientEntry.getValue().getReady()){
                readyCount++;
            }
        }

        if(readyCount == playerNumber){
            Collection<Player> values = participants.values();
            user = values.toArray(new Player[0]);
            gameState = GameState.RUNNING;
            return true;
        }
        else{return false;}
    }

    @Override
    public void unready(UUID playerID){
        colorToID.remove(playerID);        
        participants.get(playerID).setUnreadyPlayer();
    }

    @Override
    public void disconnect(UUID playerID){
 
        if(gameState == GameState.SETTINGUP){
            colorToID.remove(playerID);       
            participants.remove(playerID);
        }
        else{
            //TODO alive auf false setzen
        }
    }
    
    @Override
    public boolean setSettings(JSONObject settings) {
        // TODO Auto-generated method stub
        return false;
    }

    @Override
    public void CollisionCheckerWall (){
        
        for (int i = 0; i < playerNumber; i++){
            setDriverHeads(i);
            if((driverHeadX < 0) || (driverHeadX > (boardSize-1))){ //TODO -1 checker
                user[i].eliminatePlayer();
            }
            else if ((driverHeadY < 0) || (driverHeadY > (boardSize-1))){   //TODO -1 checker
                user[i].eliminatePlayer();
            }
            else{}  //TODO empty else statement
        }
        clearObstacleArrays();          
    }

    public void CollisionCheckerTail (){
    }

    @Override
    public void CollisionCheckerFrontal (){
        collectHeadPositions();

        for(int checkfor = 0; checkfor < playerNumber; checkfor++){
            for (int others = 1; others < playerNumber; others++){
                if ((obstaclePositionsX.get(checkfor) == obstaclePositionsX.get(others)) && obstaclePositionsY.get(checkfor) == obstaclePositionsY.get(others)){
                    user[checkfor].eliminatePlayer();
                    user[others].eliminatePlayer();
                }
            }
        }
        clearObstacleArrays();
    }    

    public void setDriverHeads(int userNumber){
        driverHeadX = user[userNumber].positionX[0];
        driverHeadY = user[userNumber].positionY[0];
    }

    public void collectTailPositions(){
        for (int i = 0; i < playerNumber; i++){
            for(int k = 1; k < tailLenght; k++){
                obstaclePositionsX.add(user[i].positionX[k]);
                obstaclePositionsY.add(user[i].positionY[k]);
            }
        }
    }

    public void clearObstacleArrays(){
        obstaclePositionsX.clear();
        obstaclePositionsY.clear();
    }

    public void collectHeadPositions(){
        for(int i = 0; i < playerNumber; i++){
            obstaclePositionsX.add(user[i].positionX[0]);
            obstaclePositionsY.add(user[i].positionY[0]);
        }
    }
}
